{
".": {
  "adjust-git-emails.sh": "#!/usr/bin/env bash\n\nRED=\"\\033[0;31m\"\nNC=\"\\033[0m\"\n\n# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n# WARNING: This script may be dangerous!\n# It rewrites Git history, changing commit authors/emails.\n# Conflicts may occur, and the only rollback may be recloning.\n# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\nmain() {\n    # Warn the user about potential risks\n    echo -e \"${RED}WARNING: This will rewrite Git history, changing ALL commit authors/emails.${NC}\"\n    echo -e \"${RED}This may cause conflicts, and the only way to undo it may be to reclone the repo.${NC}\"\n    echo -e \"${RED}Are you ABSOLUTELY sure you want to proceed? (y/N)${NC}\"\n\n    # Read user input (case-insensitive)\n    read -r -p \"> \" user_input\n    choice=$(echo \"$user_input\" | tr '[:upper:]' '[:lower:]')\n\n    # Only proceed on explicit \"y\" or \"yes\" (case-insensitive)\n    if [[ \"$choice\" == \"y\" || \"$choice\" == \"yes\" ]]; then\n        echo \"Starting rebase to reset authors...\"\n        git rebase -r --root --exec \"git commit --amend --no-edit --reset-author\" || {\n            echo -e \"${RED}Rebase failed! Check Git status and resolve conflicts.${NC}\" >&2\n            exit 1\n        }\n        echo \"Successfully updated all commits.\"\n    else\n        echo \"Aborted. No changes were made.\"\n    fi\n}\n\nmain",
  "check-repos.sh": "#!/usr/bin/env bash\n\n# Checks if there are uncommitted changes in the repositories inside a \"Projects\" directory that\n# the user specify.\n# If no directory path is passed, the script will look for git repositories inside the \n# \"$HOME/Projects/\" directory.\n\nPROJECTS=\"$HOME/Projects/\"\nWARNING=\"\\033[33m\"\nERROR=\"\\033[31m\"\nNOT_PUSHED=\"\\033[38;5;190m\"\nINFO='\\033[0;36m'\nNC=\"\\033[0m\"\n\nprintMissingActions() {\n    local uncommitted=(\"${!1}\")\n    local notPushed=(\"${!2}\")\n\n    if [ ${#uncommitted[@]} -ne 0 ]; then\n        echo -e \"${WARNING}The following directories contain uncommitted changes:${NC}\"\n        for dir in \"${uncommitted[@]}\"; do\n            echo -e \"${WARNING}$dir${NC}\"\n        done\n    fi\n\n    if [ ${#notPushed[@]} -ne 0 ]; then\n        echo -e \"${NOT_PUSHED}The following directories contain changes that were commited but not yet pushed:${NC}\"\n        for dir in \"${notPushed[@]}\"; do\n            echo -e \"${NOT_PUSHED}$dir${NC}\"\n        done\n    fi\n}\n\npullChanges() {\n    local dir=$(pwd)\n    # Check for uncommitted changes\n    if [[ -n $(git status --porcelain) ]]; then\n        return 1\n    fi\n\n    # Check for changes commited but not yet pushed\n    if [ -n \"$(git cherry -v)\" ]; then\n        return 2\n    fi\n    \n    return 0\n}\n\nprintUsage() {\n    echo \"Usage: update-repos [PROJECTS_PATH]\"\n}\n\nsetProjectsDir() {\n    # Check if the user passed a 'Projects' directory\n    if [ $# -ne 0 ]; then\n        PROJECTS=\"$1\"\n        \n        # Ensure path ends with /\n        [[ \"$PROJECTS\" != */ ]] && PROJECTS=\"$PROJECTS/\"\n    \n        # Check if $PROJECTS directory exists\n        if [ ! -d \"$PROJECTS\" ]; then\n            echo -e \"${ERROR}error: directory $PROJECTS does not exist${NC}\"\n            printUsage\n            exit 1\n        fi\n        echo -e \"${INFO}Projects directory set to '$PROJECTS'${NC}\"\n    fi\n}\n\nmain() {\n    # Check if user passed a \"Projects\" directory\n    setProjectsDir \"$@\"\n\n    # CD into Projects directory\n    cd \"$PROJECTS\" || { echo -e \"${ERROR}Failed to cd to $PROJECTS${NC}\"; exit 1; }\n\n    # Variables for controlling errors\n    uncommittedDirectories=()\n    directoriesConflicting=()\n\n    # Iterate over directories inside $PROJECTS\n    for dir in */; do\n        [ -d \"$dir\" ] || continue  # Skip if not a directory\n        echo -e \"${INFO}Checking $dir${NC}\"\n        \n        # CD into dir\n        cd \"$dir\" || { echo -e \"${ERROR}Failed to enter $dir${NC}\"; continue; }\n  \n        # Check if $dir is a git directory \n        if git rev-parse --is-inside-work-tree &>/dev/null; then\n            pullChanges\n            case $? in\n                1) uncommittedDirectories+=(\"$(pwd)\") ;;\n                2) directoriesConflicting+=(\"$(pwd)\") ;;\n            esac\n        else\n            echo -e \"${WARNING}$dir is not a git repository${NC}\"\n        fi\n        \n        # Return to Projects directory\n        cd ..\n    done\n\n    printMissingActions uncommittedDirectories[@] directoriesConflicting[@]\n    \n    exit 0\n}\n\nmain \"$@\"",
  "collect_repo_content.sh": "#!/usr/bin/env bash\n\n# Collects all the content from the current Git repository and stores it\n# in a structured output file\n\n# Color definitions\nWARNING=\"\\033[33m\"\nERROR=\"\\033[31m\"\nINFO='\\033[0;36m'\nNC=\"\\033[0m\"\n\n# Initialize variables\nignoredFiles=()\noutput_file=\"${1:-content}\"  # Use first argument or default to \"content\"\n\ngetIgnoredFiles() {    \n    # Check if we're in a git repository\n    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then\n        echo -e \"${ERROR}Error: Not in a git repository${NC}\" >&2\n        exit 1\n    fi\n    \n    # Read .gitignore line by line\n    while IFS= read -r pattern || [[ -n \"$pattern\" ]]; do\n        # Skip empty lines and comments\n        if [[ -z \"$pattern\" || \"$pattern\" == \\#* ]]; then\n            continue\n        fi\n        \n        # Remove leading/trailing whitespace\n        pattern=\"${pattern#\"${pattern%%[![:space:]]*}\"}\"\n        pattern=\"${pattern%\"${pattern##*[![:space:]]}\"}\"\n        \n        # Skip if empty after trimming\n        [[ -z \"$pattern\" ]] && continue\n        \n        # Use git to find matching files\n        while IFS= read -r -d $'\\0' file; do\n            ignoredFiles+=(\"$file\")\n        done < <(git ls-files -z --ignored --exclude=\"$pattern\")\n    done < .gitignore\n}\n\nisIgnored() {\n    local file=\"$1\"\n    \n    # Skip hidden directories and files (except .git which is already handled)\n    if [[ \"$file\" == ./* ]] && [[ \"$file\" =~ /\\. ]]; then\n        return 0\n    fi\n    \n    for ignored in \"${ignoredFiles[@]}\"; do\n        if [[ \"$file\" == \"$ignored\" ]]; then\n            return 0\n        fi\n    done\n    return 1\n}\n\nprocessDirectory() {\n    local dir=\"$1\"\n    local indent=\"$2\"\n    local first_file=true\n    \n    # Log current directory\n    echo -e \"${INFO}Processing directory ${WARNING}'$dir'${NC}\"\n\n    # Open directory bracket\n    printf '%s\"%s\": {\\n' \"$indent\" \"$dir\" >> \"$output_file\"\n    \n    # Process files\n    while IFS= read -r -d $'\\0' file; do\n        if ! isIgnored \"${file#./}\"; then\n            if [ \"$first_file\" = false ]; then\n                printf ',\\n' >> \"$output_file\"\n            fi\n            first_file=false\n            \n            # Get file content and escape special characters\n            local content=$(sed -e 's/\\\\/\\\\\\\\/g' -e 's/\"/\\\\\"/g' -e 's/$/\\\\n/' \"$file\" | tr -d '\\n')\n            \n            # Remove trailing backslash+n if exists\n            content=\"${content%\\\\n}\"\n            \n            printf '%s  \"%s\": \"%s\"' \"$indent\" \"$(basename \"$file\")\" \"$content\" >> \"$output_file\"\n        fi\n    done < <(find \"$dir\" -maxdepth 1 -type f ! -name \".*\" -print0 | sort -z)\n    \n    # Process subdirectories (excluding hidden dirs except .git)\n    while IFS= read -r -d $'\\0' subdir; do\n        local dirname=$(basename \"$subdir\")\n        if [ \"$dirname\" != \".\" ] && [ \"$dirname\" != \"..\" ] && [[ \"$dirname\" != .* || \"$dirname\" == \".git\" ]]; then\n            if ! isIgnored \"${subdir#./}\"; then\n                if [ \"$first_file\" = false ]; then\n                    printf ',\\n' >> \"$output_file\"\n                fi\n                first_file=false\n                processDirectory \"${subdir#./}\" \"$indent  \"\n            fi\n        fi\n    done < <(find \"$dir\" -maxdepth 1 -type d ! -name \".*\" -print0 | sort -z)\n    \n    # Close directory bracket\n    printf '\\n%s}' \"$indent\" >> \"$output_file\"\n    echo -e \"${INFO}Finished processing directory ${WARNING}'$dir'${NC}\"\n}\n\nmain() {\n    # Get the ignored files    \n    getIgnoredFiles\n    \n    # Print ignored files for info\n    if [ ${#ignoredFiles[@]} -ne 0 ]; then\n        echo -e \"${WARNING}Ignoring the following files:${NC}\"\n        printf '%s\\n' \"${ignoredFiles[@]}\"\n        echo\n    fi\n    \n    # Initialize output file\n    echo -e \"${INFO}Creating output file: $output_file${NC}\"\n    echo \"{\" > \"$output_file\"\n    \n    # Process current directory\n    processDirectory \".\" \"\"\n    \n    # Close the root bracket\n    echo -e \"\\n}\" >> \"$output_file\"\n    \n    echo -e \"${INFO}Repository content successfully saved to $output_file${NC}\"\n}\n\nmain \"$@\"",
  "content": "{\n\".\": {\n  \"adjust-git-emails.sh\": \"#!/usr/bin/env bash\\n\\nRED=\\\"\\\\033[0;31m\\\"\\nNC=\\\"\\\\033[0m\\\"\\n\\n# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n# WARNING: This script may be dangerous!\\n# It rewrites Git history, changing commit authors/emails.\\n# Conflicts may occur, and the only rollback may be recloning.\\n# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nmain() {\\n    # Warn the user about potential risks\\n    echo -e \\\"${RED}WARNING: This will rewrite Git history, changing ALL commit authors/emails.${NC}\\\"\\n    echo -e \\\"${RED}This may cause conflicts, and the only way to undo it may be to reclone the repo.${NC}\\\"\\n    echo -e \\\"${RED}Are you ABSOLUTELY sure you want to proceed? (y/N)${NC}\\\"\\n\\n    # Read user input (case-insensitive)\\n    read -r -p \\\"> \\\" user_input\\n    choice=$(echo \\\"$user_input\\\" | tr '[:upper:]' '[:lower:]')\\n\\n    # Only proceed on explicit \\\"y\\\" or \\\"yes\\\" (case-insensitive)\\n    if [[ \\\"$choice\\\" == \\\"y\\\" || \\\"$choice\\\" == \\\"yes\\\" ]]; then\\n        echo \\\"Starting rebase to reset authors...\\\"\\n        git rebase -r --root --exec \\\"git commit --amend --no-edit --reset-author\\\" || {\\n            echo -e \\\"${RED}Rebase failed! Check Git status and resolve conflicts.${NC}\\\" >&2\\n            exit 1\\n        }\\n        echo \\\"Successfully updated all commits.\\\"\\n    else\\n        echo \\\"Aborted. No changes were made.\\\"\\n    fi\\n}\\n\\nmain\",\n  \"check-repos.sh\": \"#!/usr/bin/env bash\\n\\n# Checks if there are uncommitted changes in the repositories inside a \\\"Projects\\\" directory that\\n# the user specify.\\n# If no directory path is passed, the script will look for git repositories inside the \\n# \\\"$HOME/Projects/\\\" directory.\\n\\nPROJECTS=\\\"$HOME/Projects/\\\"\\nWARNING=\\\"\\\\033[33m\\\"\\nERROR=\\\"\\\\033[31m\\\"\\nNOT_PUSHED=\\\"\\\\033[38;5;190m\\\"\\nINFO='\\\\033[0;36m'\\nNC=\\\"\\\\033[0m\\\"\\n\\nprintMissingActions() {\\n    local uncommitted=(\\\"${!1}\\\")\\n    local notPushed=(\\\"${!2}\\\")\\n\\n    if [ ${#uncommitted[@]} -ne 0 ]; then\\n        echo -e \\\"${WARNING}The following directories contain uncommitted changes:${NC}\\\"\\n        for dir in \\\"${uncommitted[@]}\\\"; do\\n            echo -e \\\"${WARNING}$dir${NC}\\\"\\n        done\\n    fi\\n\\n    if [ ${#notPushed[@]} -ne 0 ]; then\\n        echo -e \\\"${NOT_PUSHED}The following directories contain changes that were commited but not yet pushed:${NC}\\\"\\n        for dir in \\\"${notPushed[@]}\\\"; do\\n            echo -e \\\"${NOT_PUSHED}$dir${NC}\\\"\\n        done\\n    fi\\n}\\n\\npullChanges() {\\n    local dir=$(pwd)\\n    # Check for uncommitted changes\\n    if [[ -n $(git status --porcelain) ]]; then\\n        return 1\\n    fi\\n\\n    # Check for changes commited but not yet pushed\\n    if [ -n \\\"$(git cherry -v)\\\" ]; then\\n        return 2\\n    fi\\n    \\n    return 0\\n}\\n\\nprintUsage() {\\n    echo \\\"Usage: update-repos [PROJECTS_PATH]\\\"\\n}\\n\\nsetProjectsDir() {\\n    # Check if the user passed a 'Projects' directory\\n    if [ $# -ne 0 ]; then\\n        PROJECTS=\\\"$1\\\"\\n        \\n        # Ensure path ends with /\\n        [[ \\\"$PROJECTS\\\" != */ ]] && PROJECTS=\\\"$PROJECTS/\\\"\\n    \\n        # Check if $PROJECTS directory exists\\n        if [ ! -d \\\"$PROJECTS\\\" ]; then\\n            echo -e \\\"${ERROR}error: directory $PROJECTS does not exist${NC}\\\"\\n            printUsage\\n            exit 1\\n        fi\\n        echo -e \\\"${INFO}Projects directory set to '$PROJECTS'${NC}\\\"\\n    fi\\n}\\n\\nmain() {\\n    # Check if user passed a \\\"Projects\\\" directory\\n    setProjectsDir \\\"$@\\\"\\n\\n    # CD into Projects directory\\n    cd \\\"$PROJECTS\\\" || { echo -e \\\"${ERROR}Failed to cd to $PROJECTS${NC}\\\"; exit 1; }\\n\\n    # Variables for controlling errors\\n    uncommittedDirectories=()\\n    directoriesConflicting=()\\n\\n    # Iterate over directories inside $PROJECTS\\n    for dir in */; do\\n        [ -d \\\"$dir\\\" ] || continue  # Skip if not a directory\\n        echo -e \\\"${INFO}Checking $dir${NC}\\\"\\n        \\n        # CD into dir\\n        cd \\\"$dir\\\" || { echo -e \\\"${ERROR}Failed to enter $dir${NC}\\\"; continue; }\\n  \\n        # Check if $dir is a git directory \\n        if git rev-parse --is-inside-work-tree &>/dev/null; then\\n            pullChanges\\n            case $? in\\n                1) uncommittedDirectories+=(\\\"$(pwd)\\\") ;;\\n                2) directoriesConflicting+=(\\\"$(pwd)\\\") ;;\\n            esac\\n        else\\n            echo -e \\\"${WARNING}$dir is not a git repository${NC}\\\"\\n        fi\\n        \\n        # Return to Projects directory\\n        cd ..\\n    done\\n\\n    printMissingActions uncommittedDirectories[@] directoriesConflicting[@]\\n    \\n    exit 0\\n}\\n\\nmain \\\"$@\\\"\",\n  \"collect_repo_content.sh\": \"#!/usr/bin/env bash\\n\\n# Collects all the content from the current Git repository and stores it\\n# in a structured output file\\n\\n# Color definitions\\nWARNING=\\\"\\\\033[33m\\\"\\nERROR=\\\"\\\\033[31m\\\"\\nINFO='\\\\033[0;36m'\\nNC=\\\"\\\\033[0m\\\"\\n\\n# Initialize variables\\nignoredFiles=()\\noutput_file=\\\"${1:-content}\\\"  # Use first argument or default to \\\"content\\\"\\n\\ngetIgnoredFiles() {    \\n    # Check if we're in a git repository\\n    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then\\n        echo -e \\\"${ERROR}Error: Not in a git repository${NC}\\\" >&2\\n        exit 1\\n    fi\\n    \\n    # Read .gitignore line by line\\n    while IFS= read -r pattern || [[ -n \\\"$pattern\\\" ]]; do\\n        # Skip empty lines and comments\\n        if [[ -z \\\"$pattern\\\" || \\\"$pattern\\\" == \\\\#* ]]; then\\n            continue\\n        fi\\n        \\n        # Remove leading/trailing whitespace\\n        pattern=\\\"${pattern#\\\"${pattern%%[![:space:]]*}\\\"}\\\"\\n        pattern=\\\"${pattern%\\\"${pattern##*[![:space:]]}\\\"}\\\"\\n        \\n        # Skip if empty after trimming\\n        [[ -z \\\"$pattern\\\" ]] && continue\\n        \\n        # Use git to find matching files\\n        while IFS= read -r -d $'\\\\0' file; do\\n            ignoredFiles+=(\\\"$file\\\")\\n        done < <(git ls-files -z --ignored --exclude=\\\"$pattern\\\")\\n    done < .gitignore\\n}\\n\\nisIgnored() {\\n    local file=\\\"$1\\\"\\n    \\n    # Skip hidden directories and files (except .git which is already handled)\\n    if [[ \\\"$file\\\" == ./* ]] && [[ \\\"$file\\\" =~ /\\\\. ]]; then\\n        return 0\\n    fi\\n    \\n    for ignored in \\\"${ignoredFiles[@]}\\\"; do\\n        if [[ \\\"$file\\\" == \\\"$ignored\\\" ]]; then\\n            return 0\\n        fi\\n    done\\n    return 1\\n}\\n\\nprocessDirectory() {\\n    local dir=\\\"$1\\\"\\n    local indent=\\\"$2\\\"\\n    local first_file=true\\n    \\n    # Log current directory\\n    echo -e \\\"${INFO}Processing directory ${WARNING}'$dir'${NC}\\\"\\n\\n    # Open directory bracket\\n    printf '%s\\\"%s\\\": {\\\\n' \\\"$indent\\\" \\\"$dir\\\" >> \\\"$output_file\\\"\\n    \\n    # Process files\\n    while IFS= read -r -d $'\\\\0' file; do\\n        if ! isIgnored \\\"${file#./}\\\"; then\\n            if [ \\\"$first_file\\\" = false ]; then\\n                printf ',\\\\n' >> \\\"$output_file\\\"\\n            fi\\n            first_file=false\\n            \\n            # Get file content and escape special characters\\n            local content=$(sed -e 's/\\\\\\\\/\\\\\\\\\\\\\\\\/g' -e 's/\\\"/\\\\\\\\\\\"/g' -e 's/$/\\\\\\\\n/' \\\"$file\\\" | tr -d '\\\\n')\\n            \\n            # Remove trailing backslash+n if exists\\n            content=\\\"${content%\\\\\\\\n}\\\"\\n            \\n            printf '%s  \\\"%s\\\": \\\"%s\\\"' \\\"$indent\\\" \\\"$(basename \\\"$file\\\")\\\" \\\"$content\\\" >> \\\"$output_file\\\"\\n        fi\\n    done < <(find \\\"$dir\\\" -maxdepth 1 -type f ! -name \\\".*\\\" -print0 | sort -z)\\n    \\n    # Process subdirectories (excluding hidden dirs except .git)\\n    while IFS= read -r -d $'\\\\0' subdir; do\\n        local dirname=$(basename \\\"$subdir\\\")\\n        if [ \\\"$dirname\\\" != \\\".\\\" ] && [ \\\"$dirname\\\" != \\\"..\\\" ] && [[ \\\"$dirname\\\" != .* || \\\"$dirname\\\" == \\\".git\\\" ]]; then\\n            if ! isIgnored \\\"${subdir#./}\\\"; then\\n                if [ \\\"$first_file\\\" = false ]; then\\n                    printf ',\\\\n' >> \\\"$output_file\\\"\\n                fi\\n                first_file=false\\n                processDirectory \\\"${subdir#./}\\\" \\\"$indent  \\\"\\n            fi\\n        fi\\n    done < <(find \\\"$dir\\\" -maxdepth 1 -type d ! -name \\\".*\\\" -print0 | sort -z)\\n    \\n    # Close directory bracket\\n    printf '\\\\n%s}' \\\"$indent\\\" >> \\\"$output_file\\\"\\n    echo -e \\\"${INFO}Finished processing directory ${WARNING}'$dir'${NC}\\\"\\n}\\n\\nmain() {\\n    # Get the ignored files    \\n    getIgnoredFiles\\n    \\n    # Print ignored files for info\\n    if [ ${#ignoredFiles[@]} -ne 0 ]; then\\n        echo -e \\\"${WARNING}Ignoring the following files:${NC}\\\"\\n        printf '%s\\\\n' \\\"${ignoredFiles[@]}\\\"\\n        echo\\n    fi\\n    \\n    # Initialize output file\\n    echo -e \\\"${INFO}Creating output file: $output_file${NC}\\\"\\n    echo \\\"{\\\" > \\\"$output_file\\\"\\n    \\n    # Process current directory\\n    processDirectory \\\".\\\" \\\"\\\"\\n    \\n    # Close the root bracket\\n    echo -e \\\"\\\\n}\\\" >> \\\"$output_file\\\"\\n    \\n    echo -e \\\"${INFO}Repository content successfully saved to $output_file${NC}\\\"\\n}\\n\\nmain \\\"$@\\\"\",",
  "list-authors.sh": "#!/bin/env bash \n\n# Lists all the authors of a Git repository\n\nERROR=\"\\033[31m\"\nINFO='\\033[0;36m'\nNC=\"\\033[0m\"\n\nmain() {\n    # Check if $dir is a git directory \n    if git rev-parse --is-inside-work-tree &>/dev/null; then\n        git shortlog --summary --numbered --email\n    else \n        echo -e \"${ERROR}error: not a Git repository${NC}\"\n    fi\n}\n\nmain ",
  "pull-repos.sh": "#!/usr/bin/env bash\n\n# Pulls the latest changes from all git repositories inside a \"Projects\" directory that\n# the user specify.\n# If no directory path is passed, the script will look for git repositories inside the \n# \"$HOME/Projects/\" directory.\n\nPROJECTS=\"$HOME/Projects/\"\nWARNING=\"\\033[33m\"\nERROR=\"\\033[31m\"\nINFO='\\033[0;36m'\nNC=\"\\033[0m\"\n\nprintMissingActions() {\n    local uncommitted=(\"${!1}\")\n    local conflicting=(\"${!2}\")\n\n    if [ ${#uncommitted[@]} -ne 0 ]; then\n        echo -e \"${WARNING}The following directories contain uncommitted changes:${NC}\"\n        for dir in \"${uncommitted[@]}\"; do\n            echo -e \"${WARNING}$dir${NC}\"\n        done\n    fi\n\n    if [ ${#conflicting[@]} -ne 0 ]; then\n        echo -e \"${ERROR}The following directories had conflicts when pulling:${NC}\"\n        for dir in \"${conflicting[@]}\"; do\n            echo \"${ERROR}$dir${NC}\"\n        done\n    fi\n}\n\npullChanges() {\n    local dir=$(pwd)\n    # Check for uncommitted changes\n    if [[ -n $(git status --porcelain) ]]; then\n        return 1\n    fi\n    \n    # Try to pull changes\n    if ! git pull --quiet; then\n        branch=$(git symbolic-ref --short HEAD)\n        echo -e \"${ERROR}aborting merge...${NC}\"\n        git merge --abort\n        return 2\n    fi\n    \n    return 0\n}\n\nprintUsage() {\n    echo \"Usage: update-repos [PROJECTS_PATH]\"\n}\n\nsetProjectsDir() {\n    # Check if the user passed a 'Projects' directory\n    if [ $# -ne 0 ]; then\n        PROJECTS=\"$1\"\n        \n        # Ensure path ends with /\n        [[ \"$PROJECTS\" != */ ]] && PROJECTS=\"$PROJECTS/\"\n    \n        # Check if $PROJECTS directory exists\n        if [ ! -d \"$PROJECTS\" ]; then\n            echo -e \"${ERROR}error: directory $PROJECTS does not exist${NC}\"\n            printUsage\n            exit 1\n        fi\n        echo \"${INFO}Projects directory set to '$PROJECTS'${NC}\"\n    fi\n}\n\nmain() {\n    # Check if user passed a \"Projects\" directory\n    setProjectsDir \"$@\"\n\n    # CD into Projects directory\n    cd \"$PROJECTS\" || { echo -e \"${ERROR}error: failed to cd to $PROJECTS${NC}\"; exit 1; }\n\n    # Variables for controlling errors\n    uncommittedDirectories=()\n    directoriesConflicting=()\n\n    # Iterate over directories inside $PROJECTS\n    for dir in */; do\n        [ -d \"$dir\" ] || continue  # Skip if not a directory\n        echo -e \"${INFO}Checking $dir${NC}\"\n        \n        # CD into dir\n        cd \"$dir\" || { echo -e \"${ERROR}error: failed to enter $dir${NC}\"; continue; }\n  \n        # Check if $dir is a git directory \n        if git rev-parse --is-inside-work-tree &>/dev/null; then\n            pullChanges\n            case $? in\n                1) uncommittedDirectories+=(\"$(pwd)\") ;;\n                2) directoriesConflicting+=(\"$(pwd)\") ;;\n            esac\n        else\n            echo -e \"${WARNING}$dir is not a git repository${NC}\"\n        fi\n        \n        # Return to Projects directory\n        cd ..\n    done\n\n    printMissingActions uncommittedDirectories[@] directoriesConflicting[@]\n    \n    exit 0\n}\n\nmain \"$@\"",
  "push-repos.sh": "#!/usr/bin/env bash\n\n# Pushes local changes to remote repositories for all git repositories inside a \"Projects\" directory\n# that the user specifies. If no directory path is passed, the script will look for git repositories\n# inside the \"$HOME/Projects/\" directory.\n\nPROJECTS=\"$HOME/Projects/\"\nWARNING=\"\\033[33m\"\nERROR=\"\\033[31m\"\nINFO='\\033[0;36m'\nNC=\"\\033[0m\"\n\nprintStatus() {\n    local uncommitted=(\"${!1}\")\n    local unpushed=(\"${!2}\")\n    local failed=(\"${!3}\")\n\n    if [ ${#uncommitted[@]} -ne 0 ]; then\n        echo -e \"${WARNING}The following directories contain uncommitted changes:${NC}\"\n        for dir in \"${uncommitted[@]}\"; do\n            echo -e \"${WARNING}$dir${NC}\"\n        done\n    fi\n\n    if [ ${#unpushed[@]} -ne 0 ]; then\n        echo -e \"${WARNING}The following directories have commits not yet pushed:${NC}\"\n        for dir in \"${unpushed[@]}\"; do\n            echo -e \"${WARNING}$dir${NC}\"\n        done\n    fi\n\n    if [ ${#failed[@]} -ne 0 ]; then\n        echo -e \"${ERROR}Failed to push changes in the following directories:${NC}\"\n        for dir in \"${failed[@]}\"; do\n            echo -e \"${ERROR}$dir${NC}\"}\n        done\n    fi\n}\n\npushChanges() {\n    # Check for uncommitted changes\n    if [[ -n $(git status --porcelain) ]]; then\n        return 1\n    fi\n    \n    # Check if there are commits to push\n    local branch=$(git symbolic-ref --short HEAD 2>/dev/null)\n    if [ -z \"$branch\" ]; then\n        # Not on any branch (detached HEAD)\n        return 0\n    fi\n    \n    local upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)\n    if [ -z \"$upstream\" ]; then\n        # No upstream branch set\n        return 0\n    fi\n    \n    local local_commit=$(git rev-parse @)\n    local remote_commit=$(git rev-parse \"$upstream\")\n    local base_commit=$(git merge-base @ \"$upstream\")\n    \n    if [ \"$local_commit\" = \"$remote_commit\" ]; then\n        # Up to date\n        return 0\n    elif [ \"$local_commit\" = \"$base_commit\" ]; then\n        # Need to pull\n        return 2\n    elif [ \"$remote_commit\" = \"$base_commit\" ]; then\n        # Need to push\n        if ! git push; then\n            return 3\n        fi\n    else\n        # Diverged\n        return 4\n    fi\n    \n    return 0\n}\n\nprintUsage() {\n    echo \"Usage: push-repos [PROJECTS_PATH]\"\n}\n\nsetProjectsDir() {\n    # Check if the user passed a 'Projects' directory\n    if [ $# -ne 0 ]; then\n        PROJECTS=\"$1\"\n        \n        # Ensure path ends with /\n        [[ \"$PROJECTS\" != */ ]] && PROJECTS=\"$PROJECTS/\"\n    \n        # Check if $PROJECTS directory exists\n        if [ ! -d \"$PROJECTS\" ]; then\n            echo -e \"${ERROR}error: directory $PROJECTS does not exist${NC}\"\n            printUsage\n            exit 1\n        fi\n        echo \"${INFO}Projects directory set to '$PROJECTS'${NC}\"\n    fi\n}\n\nmain() {\n    # Check if user passed a \"Projects\" directory\n    setProjectsDir \"$@\"\n\n    # CD into Projects directory\n    cd \"$PROJECTS\" || { echo -e \"${ERROR}Failed to cd to $PROJECTS${NC}\"; exit 1; }\n\n    # Variables for tracking status\n    uncommittedDirectories=()\n    unpushedDirectories=()\n    failedPushDirectories=()\n\n    # Iterate over directories inside $PROJECTS\n    for dir in */; do\n        [ -d \"$dir\" ] || continue  # Skip if not a directory\n        echo -e \"${INFO}Checking $dir${NC}\"\n        \n        # CD into dir\n        cd \"$dir\" || { echo -e \"${ERROR}Failed to enter $dir${NC}\"; continue; }\n  \n        # Check if $dir is a git directory \n        if git rev-parse --is-inside-work-tree &>/dev/null; then\n            pushChanges\n            case $? in\n                1) uncommittedDirectories+=(\"$(pwd)\") ;;\n                2) unpushedDirectories+=(\"$(pwd)\") ;;\n                3) failedPushDirectories+=(\"$(pwd)\") ;;\n                4) \n                    unpushedDirectories+=(\"$(pwd)\")\n                    failedPushDirectories+=(\"$(pwd)\")\n                    ;;\n            esac\n        else\n            echo -e \"${WARNING}$dir is not a git repository${NC}\"\n        fi\n        \n        # Return to Projects directory\n        cd ..\n    done\n\n    printStatus uncommittedDirectories[@] unpushedDirectories[@] failedPushDirectories[@]\n    \n    exit 0\n}\n\nmain \"$@\""
}
}
